// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const cancelRegistration = `-- name: CancelRegistration :one
UPDATE conference_registrations SET status = 'cancelled', cancelled_at = NOW()
WHERE id = $1
RETURNING id, user_id, conference_id, status, role, notes, needs_ride, has_car, registered_at, cancelled_at
`

func (q *Queries) CancelRegistration(ctx context.Context, id uuid.UUID) (ConferenceRegistration, error) {
	row := q.db.QueryRowContext(ctx, cancelRegistration, id)
	var i ConferenceRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConferenceID,
		&i.Status,
		&i.Role,
		&i.Notes,
		&i.NeedsRide,
		&i.HasCar,
		&i.RegisteredAt,
		&i.CancelledAt,
	)
	return i, err
}

const createConference = `-- name: CreateConference :one
INSERT INTO conferences (title, date, location, website, latitude, longitude, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, title, date, location, website, latitude, longitude, created_by, created_at, updated_at
`

type CreateConferenceParams struct {
	Title     string
	Date      time.Time
	Location  string
	Website   sql.NullString
	Latitude  sql.NullFloat64
	Longitude sql.NullFloat64
	CreatedBy uuid.UUID
}

func (q *Queries) CreateConference(ctx context.Context, arg CreateConferenceParams) (Conference, error) {
	row := q.db.QueryRowContext(ctx, createConference,
		arg.Title,
		arg.Date,
		arg.Location,
		arg.Website,
		arg.Latitude,
		arg.Longitude,
		arg.CreatedBy,
	)
	var i Conference
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Date,
		&i.Location,
		&i.Website,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createToken = `-- name: CreateToken :one
INSERT INTO user_tokens (user_id, token_hash)
VALUES ($1, $2)
RETURNING id, user_id, token_hash, created_at, last_used_at, revoked
`

type CreateTokenParams struct {
	UserID    uuid.UUID
	TokenHash string
}

// Token management queries (user_tokens table must be present in schema.sql)
func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (UserToken, error) {
	row := q.db.QueryRowContext(ctx, createToken, arg.UserID, arg.TokenHash)
	var i UserToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.Revoked,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password, name, nickname, city, avatar_url, bio)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, email, password, name, nickname, city, avatar_url, bio, created_at, updated_at
`

type CreateUserParams struct {
	Email     string
	Password  string
	Name      string
	Nickname  sql.NullString
	City      sql.NullString
	AvatarUrl sql.NullString
	Bio       sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Email,
		arg.Password,
		arg.Name,
		arg.Nickname,
		arg.City,
		arg.AvatarUrl,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Nickname,
		&i.City,
		&i.AvatarUrl,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllConferences = `-- name: DeleteAllConferences :exec
DELETE FROM conferences
`

func (q *Queries) DeleteAllConferences(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllConferences)
	return err
}

const deleteAllRegistrations = `-- name: DeleteAllRegistrations :exec
DELETE FROM conference_registrations
`

func (q *Queries) DeleteAllRegistrations(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllRegistrations)
	return err
}

const deleteAllUsers = `-- name: DeleteAllUsers :exec
DELETE FROM users
`

func (q *Queries) DeleteAllUsers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllUsers)
	return err
}

const deleteConference = `-- name: DeleteConference :exec
DELETE FROM conferences WHERE id = $1
`

func (q *Queries) DeleteConference(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteConference, id)
	return err
}

const deleteRegistration = `-- name: DeleteRegistration :exec
DELETE FROM conference_registrations WHERE user_id = $1 AND conference_id = $2
`

type DeleteRegistrationParams struct {
	UserID       uuid.UUID
	ConferenceID uuid.UUID
}

func (q *Queries) DeleteRegistration(ctx context.Context, arg DeleteRegistrationParams) error {
	_, err := q.db.ExecContext(ctx, deleteRegistration, arg.UserID, arg.ConferenceID)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM user_tokens WHERE id = $1
`

func (q *Queries) DeleteToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteToken, id)
	return err
}

const getConferenceByID = `-- name: GetConferenceByID :one
SELECT id, title, date, location, website, latitude, longitude, created_by, created_at, updated_at FROM conferences WHERE id = $1
`

func (q *Queries) GetConferenceByID(ctx context.Context, id uuid.UUID) (Conference, error) {
	row := q.db.QueryRowContext(ctx, getConferenceByID, id)
	var i Conference
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Date,
		&i.Location,
		&i.Website,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConferenceStats = `-- name: GetConferenceStats :one
SELECT
    c.id, c.title,
    COUNT(r.id) as total_registrations,
    COUNT(r.id) FILTER (WHERE r.status = 'registered') as confirmed_count,
    COUNT(r.id) FILTER (WHERE r.needs_ride = TRUE AND r.status != 'cancelled') as needing_ride_count,
    COUNT(r.id) FILTER (WHERE r.has_car = TRUE AND r.status != 'cancelled') as offering_ride_count
FROM conferences c
LEFT JOIN conference_registrations r ON r.conference_id = c.id
WHERE c.id = $1
GROUP BY c.id, c.title
`

type GetConferenceStatsRow struct {
	ID                 uuid.UUID
	Title              string
	TotalRegistrations int64
	ConfirmedCount     int64
	NeedingRideCount   int64
	OfferingRideCount  int64
}

func (q *Queries) GetConferenceStats(ctx context.Context, id uuid.UUID) (GetConferenceStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getConferenceStats, id)
	var i GetConferenceStatsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TotalRegistrations,
		&i.ConfirmedCount,
		&i.NeedingRideCount,
		&i.OfferingRideCount,
	)
	return i, err
}

const getRegistration = `-- name: GetRegistration :one
SELECT id, user_id, conference_id, status, role, notes, needs_ride, has_car, registered_at, cancelled_at FROM conference_registrations WHERE user_id = $1 AND conference_id = $2
`

type GetRegistrationParams struct {
	UserID       uuid.UUID
	ConferenceID uuid.UUID
}

func (q *Queries) GetRegistration(ctx context.Context, arg GetRegistrationParams) (ConferenceRegistration, error) {
	row := q.db.QueryRowContext(ctx, getRegistration, arg.UserID, arg.ConferenceID)
	var i ConferenceRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConferenceID,
		&i.Status,
		&i.Role,
		&i.Notes,
		&i.NeedsRide,
		&i.HasCar,
		&i.RegisteredAt,
		&i.CancelledAt,
	)
	return i, err
}

const getRegistrationsByConference = `-- name: GetRegistrationsByConference :many
SELECT r.id, r.user_id, r.conference_id, r.status, r.role, r.notes, r.needs_ride, r.has_car, r.registered_at, r.cancelled_at,
       u.email, u.name, u.nickname, u.city, u.avatar_url
FROM conference_registrations r
JOIN users u ON u.id = r.user_id
WHERE r.conference_id = $1
`

type GetRegistrationsByConferenceRow struct {
	ID           uuid.UUID
	UserID       uuid.UUID
	ConferenceID uuid.UUID
	Status       string
	Role         string
	Notes        sql.NullString
	NeedsRide    sql.NullBool
	HasCar       sql.NullBool
	RegisteredAt sql.NullTime
	CancelledAt  sql.NullTime
	Email        string
	Name         string
	Nickname     sql.NullString
	City         sql.NullString
	AvatarUrl    sql.NullString
}

func (q *Queries) GetRegistrationsByConference(ctx context.Context, conferenceID uuid.UUID) ([]GetRegistrationsByConferenceRow, error) {
	rows, err := q.db.QueryContext(ctx, getRegistrationsByConference, conferenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRegistrationsByConferenceRow
	for rows.Next() {
		var i GetRegistrationsByConferenceRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ConferenceID,
			&i.Status,
			&i.Role,
			&i.Notes,
			&i.NeedsRide,
			&i.HasCar,
			&i.RegisteredAt,
			&i.CancelledAt,
			&i.Email,
			&i.Name,
			&i.Nickname,
			&i.City,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegistrationsByUser = `-- name: GetRegistrationsByUser :many
SELECT r.id, r.user_id, r.conference_id, r.status, r.role, r.notes, r.needs_ride, r.has_car, r.registered_at, r.cancelled_at,
       c.title, c.date, c.location, c.website
FROM conference_registrations r
JOIN conferences c ON c.id = r.conference_id
WHERE r.user_id = $1
`

type GetRegistrationsByUserRow struct {
	ID           uuid.UUID
	UserID       uuid.UUID
	ConferenceID uuid.UUID
	Status       string
	Role         string
	Notes        sql.NullString
	NeedsRide    sql.NullBool
	HasCar       sql.NullBool
	RegisteredAt sql.NullTime
	CancelledAt  sql.NullTime
	Title        string
	Date         time.Time
	Location     string
	Website      sql.NullString
}

func (q *Queries) GetRegistrationsByUser(ctx context.Context, userID uuid.UUID) ([]GetRegistrationsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getRegistrationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRegistrationsByUserRow
	for rows.Next() {
		var i GetRegistrationsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ConferenceID,
			&i.Status,
			&i.Role,
			&i.Notes,
			&i.NeedsRide,
			&i.HasCar,
			&i.RegisteredAt,
			&i.CancelledAt,
			&i.Title,
			&i.Date,
			&i.Location,
			&i.Website,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenByHash = `-- name: GetTokenByHash :one
SELECT id, user_id, token_hash, created_at, last_used_at, revoked
FROM user_tokens
WHERE token_hash = $1
`

func (q *Queries) GetTokenByHash(ctx context.Context, tokenHash string) (UserToken, error) {
	row := q.db.QueryRowContext(ctx, getTokenByHash, tokenHash)
	var i UserToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.Revoked,
	)
	return i, err
}

const getTokensByUser = `-- name: GetTokensByUser :many
SELECT id, user_id, token_hash, created_at, last_used_at, revoked
FROM user_tokens
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetTokensByUser(ctx context.Context, userID uuid.UUID) ([]UserToken, error) {
	rows, err := q.db.QueryContext(ctx, getTokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserToken
	for rows.Next() {
		var i UserToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.Revoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password, name, nickname, city, avatar_url, bio, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Nickname,
		&i.City,
		&i.AvatarUrl,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password, name, nickname, city, avatar_url, bio, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Nickname,
		&i.City,
		&i.AvatarUrl,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listConferences = `-- name: ListConferences :many
SELECT id, title, date, location, website, latitude, longitude, created_by, created_at, updated_at FROM conferences ORDER BY date DESC
`

func (q *Queries) ListConferences(ctx context.Context) ([]Conference, error) {
	rows, err := q.db.QueryContext(ctx, listConferences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conference
	for rows.Next() {
		var i Conference
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Date,
			&i.Location,
			&i.Website,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConferencesByLocation = `-- name: ListConferencesByLocation :many
SELECT id, title, date, location, website, latitude, longitude, created_by, created_at, updated_at FROM conferences WHERE location ILIKE $1 ORDER BY date DESC
`

func (q *Queries) ListConferencesByLocation(ctx context.Context, location string) ([]Conference, error) {
	rows, err := q.db.QueryContext(ctx, listConferencesByLocation, location)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conference
	for rows.Next() {
		var i Conference
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Date,
			&i.Location,
			&i.Website,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingConferences = `-- name: ListUpcomingConferences :many
SELECT id, title, date, location, website, latitude, longitude, created_by, created_at, updated_at FROM conferences WHERE date >= NOW() ORDER BY date ASC
`

func (q *Queries) ListUpcomingConferences(ctx context.Context) ([]Conference, error) {
	rows, err := q.db.QueryContext(ctx, listUpcomingConferences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conference
	for rows.Next() {
		var i Conference
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Date,
			&i.Location,
			&i.Website,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersNeedingRide = `-- name: ListUsersNeedingRide :many
SELECT u.id, u.email, u.password, u.name, u.nickname, u.city, u.avatar_url, u.bio, u.created_at, u.updated_at,
       c.title, c.location, r.notes
FROM conference_registrations r
JOIN users u ON u.id = r.user_id
JOIN conferences c ON c.id = r.conference_id
WHERE r.conference_id = $1 AND r.needs_ride = TRUE AND r.status != 'cancelled'
`

type ListUsersNeedingRideRow struct {
	ID        uuid.UUID
	Email     string
	Password  string
	Name      string
	Nickname  sql.NullString
	City      sql.NullString
	AvatarUrl sql.NullString
	Bio       sql.NullString
	CreatedAt sql.NullTime
	UpdatedAt sql.NullTime
	Title     string
	Location  string
	Notes     sql.NullString
}

func (q *Queries) ListUsersNeedingRide(ctx context.Context, conferenceID uuid.UUID) ([]ListUsersNeedingRideRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersNeedingRide, conferenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersNeedingRideRow
	for rows.Next() {
		var i ListUsersNeedingRideRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Password,
			&i.Name,
			&i.Nickname,
			&i.City,
			&i.AvatarUrl,
			&i.Bio,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Location,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersOfferingRide = `-- name: ListUsersOfferingRide :many
SELECT u.id, u.email, u.password, u.name, u.nickname, u.city, u.avatar_url, u.bio, u.created_at, u.updated_at,
       c.title, c.location, r.notes
FROM conference_registrations r
JOIN users u ON u.id = r.user_id
JOIN conferences c ON c.id = r.conference_id
WHERE r.conference_id = $1 AND r.has_car = TRUE AND r.status != 'cancelled'
`

type ListUsersOfferingRideRow struct {
	ID        uuid.UUID
	Email     string
	Password  string
	Name      string
	Nickname  sql.NullString
	City      sql.NullString
	AvatarUrl sql.NullString
	Bio       sql.NullString
	CreatedAt sql.NullTime
	UpdatedAt sql.NullTime
	Title     string
	Location  string
	Notes     sql.NullString
}

func (q *Queries) ListUsersOfferingRide(ctx context.Context, conferenceID uuid.UUID) ([]ListUsersOfferingRideRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersOfferingRide, conferenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersOfferingRideRow
	for rows.Next() {
		var i ListUsersOfferingRideRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Password,
			&i.Name,
			&i.Nickname,
			&i.City,
			&i.AvatarUrl,
			&i.Bio,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Location,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerUserToConference = `-- name: RegisterUserToConference :one
INSERT INTO conference_registrations (user_id, conference_id, role, notes, needs_ride, has_car)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, conference_id, status, role, notes, needs_ride, has_car, registered_at, cancelled_at
`

type RegisterUserToConferenceParams struct {
	UserID       uuid.UUID
	ConferenceID uuid.UUID
	Role         string
	Notes        sql.NullString
	NeedsRide    sql.NullBool
	HasCar       sql.NullBool
}

func (q *Queries) RegisterUserToConference(ctx context.Context, arg RegisterUserToConferenceParams) (ConferenceRegistration, error) {
	row := q.db.QueryRowContext(ctx, registerUserToConference,
		arg.UserID,
		arg.ConferenceID,
		arg.Role,
		arg.Notes,
		arg.NeedsRide,
		arg.HasCar,
	)
	var i ConferenceRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConferenceID,
		&i.Status,
		&i.Role,
		&i.Notes,
		&i.NeedsRide,
		&i.HasCar,
		&i.RegisteredAt,
		&i.CancelledAt,
	)
	return i, err
}

const revokeToken = `-- name: RevokeToken :one
UPDATE user_tokens SET revoked = true WHERE id = $1 RETURNING id, user_id, token_hash, created_at, last_used_at, revoked
`

func (q *Queries) RevokeToken(ctx context.Context, id uuid.UUID) (UserToken, error) {
	row := q.db.QueryRowContext(ctx, revokeToken, id)
	var i UserToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.Revoked,
	)
	return i, err
}

const updateConference = `-- name: UpdateConference :one
UPDATE conferences SET
    title = COALESCE($2, title),
    date = COALESCE($3, date),
    location = COALESCE($4, location),
    website = COALESCE($5, website),
    latitude = COALESCE($6, latitude),
    longitude = COALESCE($7, longitude),
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, date, location, website, latitude, longitude, created_by, created_at, updated_at
`

type UpdateConferenceParams struct {
	ID        uuid.UUID
	Title     string
	Date      time.Time
	Location  string
	Website   sql.NullString
	Latitude  sql.NullFloat64
	Longitude sql.NullFloat64
}

func (q *Queries) UpdateConference(ctx context.Context, arg UpdateConferenceParams) (Conference, error) {
	row := q.db.QueryRowContext(ctx, updateConference,
		arg.ID,
		arg.Title,
		arg.Date,
		arg.Location,
		arg.Website,
		arg.Latitude,
		arg.Longitude,
	)
	var i Conference
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Date,
		&i.Location,
		&i.Website,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRegistrationStatus = `-- name: UpdateRegistrationStatus :one
UPDATE conference_registrations SET status = $2
WHERE id = $1
RETURNING id, user_id, conference_id, status, role, notes, needs_ride, has_car, registered_at, cancelled_at
`

type UpdateRegistrationStatusParams struct {
	ID     uuid.UUID
	Status string
}

func (q *Queries) UpdateRegistrationStatus(ctx context.Context, arg UpdateRegistrationStatusParams) (ConferenceRegistration, error) {
	row := q.db.QueryRowContext(ctx, updateRegistrationStatus, arg.ID, arg.Status)
	var i ConferenceRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConferenceID,
		&i.Status,
		&i.Role,
		&i.Notes,
		&i.NeedsRide,
		&i.HasCar,
		&i.RegisteredAt,
		&i.CancelledAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
    name = COALESCE($1, name),
    nickname = COALESCE($2, nickname),
    city = COALESCE($3, city),
    avatar_url = COALESCE($4, avatar_url),
    bio = COALESCE($5, bio),
    updated_at = NOW()
WHERE id = $6
RETURNING id, email, password, name, nickname, city, avatar_url, bio, created_at, updated_at
`

type UpdateUserParams struct {
	Name      sql.NullString
	Nickname  sql.NullString
	City      sql.NullString
	AvatarUrl sql.NullString
	Bio       sql.NullString
	ID        uuid.UUID
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Name,
		arg.Nickname,
		arg.City,
		arg.AvatarUrl,
		arg.Bio,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Nickname,
		&i.City,
		&i.AvatarUrl,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users SET password = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, email, password, name, nickname, city, avatar_url, bio, created_at, updated_at
`

type UpdateUserPasswordParams struct {
	ID       uuid.UUID
	Password string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserPassword, arg.ID, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Nickname,
		&i.City,
		&i.AvatarUrl,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
