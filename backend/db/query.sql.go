// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

type Querier interface {
	CancelRegistration(ctx context.Context, id uuid.UUID) (ConferenceRegistration, error)
	CreateConference(ctx context.Context, arg CreateConferenceParams) (Conference, error)
	CreateUser(ctx context.Context, arg CreateUserParams) (User, error)
	DeleteAllConferences(ctx context.Context) error
	DeleteAllRegistrations(ctx context.Context) error
	DeleteAllUsers(ctx context.Context) error
	DeleteConference(ctx context.Context, id uuid.UUID) error
	DeleteRegistration(ctx context.Context, arg DeleteRegistrationParams) error
	GetConferenceByID(ctx context.Context, id uuid.UUID) (Conference, error)
	GetConferenceStats(ctx context.Context, id uuid.UUID) (GetConferenceStatsRow, error)
	GetRegistration(ctx context.Context, arg GetRegistrationParams) (ConferenceRegistration, error)
	GetRegistrationsByConference(ctx context.Context, conferenceID uuid.UUID) ([]GetRegistrationsByConferenceRow, error)
	GetRegistrationsByUser(ctx context.Context, userID uuid.UUID) ([]GetRegistrationsByUserRow, error)
	GetUserByEmail(ctx context.Context, email string) (User, error)
	GetUserByID(ctx context.Context, id uuid.UUID) (User, error)
	ListConferences(ctx context.Context) ([]Conference, error)
	ListConferencesByLocation(ctx context.Context, location string) ([]Conference, error)
	ListUpcomingConferences(ctx context.Context) ([]Conference, error)
	ListUsersNeedingRide(ctx context.Context, conferenceID uuid.UUID) ([]ListUsersNeedingRideRow, error)
	ListUsersOfferingRide(ctx context.Context, conferenceID uuid.UUID) ([]ListUsersOfferingRideRow, error)
	RegisterUserToConference(ctx context.Context, arg RegisterUserToConferenceParams) (ConferenceRegistration, error)
	UpdateConference(ctx context.Context, arg UpdateConferenceParams) (Conference, error)
	UpdateRegistrationStatus(ctx context.Context, arg UpdateRegistrationStatusParams) (ConferenceRegistration, error)
	UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error)
	UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error)
}

func (q *Queries) WithTx(tx DBTX) *Queries {
	return &Queries{
		db: tx,
	}
}

const cancelRegistration = `-- name: CancelRegistration :one
UPDATE conference_registrations SET status = 'cancelled', cancelled_at = NOW()
WHERE id = $1
RETURNING id, user_id, conference_id, status, role, notes, needs_ride, has_car, registered_at, cancelled_at
`

func (q *Queries) CancelRegistration(ctx context.Context, id uuid.UUID) (ConferenceRegistration, error) {
	row := q.db.QueryRow(ctx, cancelRegistration, id)
	var i ConferenceRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConferenceID,
		&i.Status,
		&i.Role,
		&i.Notes,
		&i.NeedsRide,
		&i.HasCar,
		&i.RegisteredAt,
		&i.CancelledAt,
	)
	return i, err
}

const createConference = `-- name: CreateConference :one
INSERT INTO conferences (title, date, location, website, latitude, longitude)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, title, date, location, website, latitude, longitude, created_at, updated_at
`

type CreateConferenceParams struct {
	Title     string
	Date      time.Time
	Location  string
	Website   *string
	Latitude  *float64
	Longitude *float64
}

func (q *Queries) CreateConference(ctx context.Context, arg CreateConferenceParams) (Conference, error) {
	row := q.db.QueryRow(ctx, createConference,
		arg.Title,
		arg.Date,
		arg.Location,
		arg.Website,
		arg.Latitude,
		arg.Longitude,
	)
	var i Conference
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Date,
		&i.Location,
		&i.Website,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password, name, nickname, city, avatar_url, bio)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, email, password, name, nickname, city, avatar_url, bio, created_at, updated_at
`

type CreateUserParams struct {
	Email     string
	Password  string
	Name      string
	Nickname  *string
	City      *string
	AvatarUrl *string
	Bio       *string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Password,
		arg.Name,
		arg.Nickname,
		arg.City,
		arg.AvatarUrl,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Nickname,
		&i.City,
		&i.AvatarUrl,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllConferences = `-- name: DeleteAllConferences :exec
DELETE FROM conferences
`

func (q *Queries) DeleteAllConferences(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllConferences)
	return err
}

const deleteAllRegistrations = `-- name: DeleteAllRegistrations :exec
DELETE FROM conference_registrations
`

func (q *Queries) DeleteAllRegistrations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllRegistrations)
	return err
}

const deleteAllUsers = `-- name: DeleteAllUsers :exec
DELETE FROM users
`

func (q *Queries) DeleteAllUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllUsers)
	return err
}

const deleteConference = `-- name: DeleteConference :exec
DELETE FROM conferences WHERE id = $1
`

func (q *Queries) DeleteConference(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteConference, id)
	return err
}

const deleteRegistration = `-- name: DeleteRegistration :exec
DELETE FROM conference_registrations WHERE user_id = $1 AND conference_id = $2
`

type DeleteRegistrationParams struct {
	UserID       uuid.UUID
	ConferenceID uuid.UUID
}

func (q *Queries) DeleteRegistration(ctx context.Context, arg DeleteRegistrationParams) error {
	_, err := q.db.Exec(ctx, deleteRegistration, arg.UserID, arg.ConferenceID)
	return err
}

const getConferenceByID = `-- name: GetConferenceByID :one
SELECT id, title, date, location, website, latitude, longitude, created_at, updated_at FROM conferences WHERE id = $1
`

func (q *Queries) GetConferenceByID(ctx context.Context, id uuid.UUID) (Conference, error) {
	row := q.db.QueryRow(ctx, getConferenceByID, id)
	var i Conference
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Date,
		&i.Location,
		&i.Website,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConferenceStats = `-- name: GetConferenceStats :one
SELECT
    c.id, c.title,
    COUNT(r.id) as total_registrations,
    COUNT(r.id) FILTER (WHERE r.status = 'registered') as confirmed_count,
    COUNT(r.id) FILTER (WHERE r.needs_ride = TRUE AND r.status != 'cancelled') as needing_ride_count,
    COUNT(r.id) FILTER (WHERE r.has_car = TRUE AND r.status != 'cancelled') as offering_ride_count
FROM conferences c
LEFT JOIN conference_registrations r ON r.conference_id = c.id
WHERE c.id = $1
GROUP BY c.id, c.title
`

type GetConferenceStatsRow struct {
	ID                 uuid.UUID
	Title              string
	TotalRegistrations int64
	ConfirmedCount     int64
	NeedingRideCount   int64
	OfferingRideCount  int64
}

func (q *Queries) GetConferenceStats(ctx context.Context, id uuid.UUID) (GetConferenceStatsRow, error) {
	row := q.db.QueryRow(ctx, getConferenceStats, id)
	var i GetConferenceStatsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TotalRegistrations,
		&i.ConfirmedCount,
		&i.NeedingRideCount,
		&i.OfferingRideCount,
	)
	return i, err
}

const getRegistration = `-- name: GetRegistration :one
SELECT id, user_id, conference_id, status, role, notes, needs_ride, has_car, registered_at, cancelled_at FROM conference_registrations WHERE user_id = $1 AND conference_id = $2
`

type GetRegistrationParams struct {
	UserID       uuid.UUID
	ConferenceID uuid.UUID
}

func (q *Queries) GetRegistration(ctx context.Context, arg GetRegistrationParams) (ConferenceRegistration, error) {
	row := q.db.QueryRow(ctx, getRegistration, arg.UserID, arg.ConferenceID)
	var i ConferenceRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConferenceID,
		&i.Status,
		&i.Role,
		&i.Notes,
		&i.NeedsRide,
		&i.HasCar,
		&i.RegisteredAt,
		&i.CancelledAt,
	)
	return i, err
}

const getRegistrationsByConference = `-- name: GetRegistrationsByConference :many
SELECT r.id, r.user_id, r.conference_id, r.status, r.role, r.notes, r.needs_ride, r.has_car, r.registered_at, r.cancelled_at,
       u.email, u.name, u.nickname, u.city, u.avatar_url
FROM conference_registrations r
JOIN users u ON u.id = r.user_id
WHERE r.conference_id = $1
`

type GetRegistrationsByConferenceRow struct {
	ID           uuid.UUID
	UserID       uuid.UUID
	ConferenceID uuid.UUID
	Status       string
	Role         string
	Notes        *string
	NeedsRide    bool
	HasCar       bool
	RegisteredAt time.Time
	CancelledAt  *time.Time
	Email        string
	Name         string
	Nickname     *string
	City         *string
	AvatarUrl    *string
}

func (q *Queries) GetRegistrationsByConference(ctx context.Context, conferenceID uuid.UUID) ([]GetRegistrationsByConferenceRow, error) {
	rows, err := q.db.Query(ctx, getRegistrationsByConference, conferenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRegistrationsByConferenceRow
	for rows.Next() {
		var i GetRegistrationsByConferenceRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ConferenceID,
			&i.Status,
			&i.Role,
			&i.Notes,
			&i.NeedsRide,
			&i.HasCar,
			&i.RegisteredAt,
			&i.CancelledAt,
			&i.Email,
			&i.Name,
			&i.Nickname,
			&i.City,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegistrationsByUser = `-- name: GetRegistrationsByUser :many
SELECT r.id, r.user_id, r.conference_id, r.status, r.role, r.notes, r.needs_ride, r.has_car, r.registered_at, r.cancelled_at,
       c.title, c.date, c.location, c.website
FROM conference_registrations r
JOIN conferences c ON c.id = r.conference_id
WHERE r.user_id = $1
`

type GetRegistrationsByUserRow struct {
	ID           uuid.UUID
	UserID       uuid.UUID
	ConferenceID uuid.UUID
	Status       string
	Role         string
	Notes        *string
	NeedsRide    bool
	HasCar       bool
	RegisteredAt time.Time
	CancelledAt  *time.Time
	Title        string
	Date         time.Time
	Location     string
	Website      *string
}

func (q *Queries) GetRegistrationsByUser(ctx context.Context, userID uuid.UUID) ([]GetRegistrationsByUserRow, error) {
	rows, err := q.db.Query(ctx, getRegistrationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRegistrationsByUserRow
	for rows.Next() {
		var i GetRegistrationsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ConferenceID,
			&i.Status,
			&i.Role,
			&i.Notes,
			&i.NeedsRide,
			&i.HasCar,
			&i.RegisteredAt,
			&i.CancelledAt,
			&i.Title,
			&i.Date,
			&i.Location,
			&i.Website,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password, name, nickname, city, avatar_url, bio, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Nickname,
		&i.City,
		&i.AvatarUrl,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password, name, nickname, city, avatar_url, bio, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Nickname,
		&i.City,
		&i.AvatarUrl,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listConferences = `-- name: ListConferences :many
SELECT id, title, date, location, website, latitude, longitude, created_at, updated_at FROM conferences ORDER BY date DESC
`

func (q *Queries) ListConferences(ctx context.Context) ([]Conference, error) {
	rows, err := q.db.Query(ctx, listConferences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conference
	for rows.Next() {
		var i Conference
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Date,
			&i.Location,
			&i.Website,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConferencesByLocation = `-- name: ListConferencesByLocation :many
SELECT id, title, date, location, website, latitude, longitude, created_at, updated_at FROM conferences WHERE location ILIKE $1 ORDER BY date DESC
`

func (q *Queries) ListConferencesByLocation(ctx context.Context, location string) ([]Conference, error) {
	rows, err := q.db.Query(ctx, listConferencesByLocation, location)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conference
	for rows.Next() {
		var i Conference
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Date,
			&i.Location,
			&i.Website,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingConferences = `-- name: ListUpcomingConferences :many
SELECT id, title, date, location, website, latitude, longitude, created_at, updated_at FROM conferences WHERE date >= NOW() ORDER BY date ASC
`

func (q *Queries) ListUpcomingConferences(ctx context.Context) ([]Conference, error) {
	rows, err := q.db.Query(ctx, listUpcomingConferences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conference
	for rows.Next() {
		var i Conference
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Date,
			&i.Location,
			&i.Website,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersNeedingRide = `-- name: ListUsersNeedingRide :many
SELECT u.id, u.email, u.password, u.name, u.nickname, u.city, u.avatar_url, u.bio, u.created_at, u.updated_at,
       c.title, c.location, r.notes
FROM conference_registrations r
JOIN users u ON u.id = r.user_id
JOIN conferences c ON c.id = r.conference_id
WHERE r.conference_id = $1 AND r.needs_ride = TRUE AND r.status != 'cancelled'
`

type ListUsersNeedingRideRow struct {
	ID        uuid.UUID
	Email     string
	Password  string
	Name      string
	Nickname  *string
	City      *string
	AvatarUrl *string
	Bio       *string
	CreatedAt time.Time
	UpdatedAt time.Time
	Title     string
	Location  string
	Notes     *string
}

func (q *Queries) ListUsersNeedingRide(ctx context.Context, conferenceID uuid.UUID) ([]ListUsersNeedingRideRow, error) {
	rows, err := q.db.Query(ctx, listUsersNeedingRide, conferenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersNeedingRideRow
	for rows.Next() {
		var i ListUsersNeedingRideRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Password,
			&i.Name,
			&i.Nickname,
			&i.City,
			&i.AvatarUrl,
			&i.Bio,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Location,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersOfferingRide = `-- name: ListUsersOfferingRide :many
SELECT u.id, u.email, u.password, u.name, u.nickname, u.city, u.avatar_url, u.bio, u.created_at, u.updated_at,
       c.title, c.location, r.notes
FROM conference_registrations r
JOIN users u ON u.id = r.user_id
JOIN conferences c ON c.id = r.conference_id
WHERE r.conference_id = $1 AND r.has_car = TRUE AND r.status != 'cancelled'
`

type ListUsersOfferingRideRow struct {
	ID        uuid.UUID
	Email     string
	Password  string
	Name      string
	Nickname  *string
	City      *string
	AvatarUrl *string
	Bio       *string
	CreatedAt time.Time
	UpdatedAt time.Time
	Title     string
	Location  string
	Notes     *string
}

func (q *Queries) ListUsersOfferingRide(ctx context.Context, conferenceID uuid.UUID) ([]ListUsersOfferingRideRow, error) {
	rows, err := q.db.Query(ctx, listUsersOfferingRide, conferenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersOfferingRideRow
	for rows.Next() {
		var i ListUsersOfferingRideRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Password,
			&i.Name,
			&i.Nickname,
			&i.City,
			&i.AvatarUrl,
			&i.Bio,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Location,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerUserToConference = `-- name: RegisterUserToConference :one
INSERT INTO conference_registrations (user_id, conference_id, role, notes, needs_ride, has_car)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, conference_id, status, role, notes, needs_ride, has_car, registered_at, cancelled_at
`

type RegisterUserToConferenceParams struct {
	UserID       uuid.UUID
	ConferenceID uuid.UUID
	Role         UserRole
	Notes        *string
	NeedsRide    bool
	HasCar       bool
}

func (q *Queries) RegisterUserToConference(ctx context.Context, arg RegisterUserToConferenceParams) (ConferenceRegistration, error) {
	row := q.db.QueryRow(ctx, registerUserToConference,
		arg.UserID,
		arg.ConferenceID,
		arg.Role,
		arg.Notes,
		arg.NeedsRide,
		arg.HasCar,
	)
	var i ConferenceRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConferenceID,
		&i.Status,
		&i.Role,
		&i.Notes,
		&i.NeedsRide,
		&i.HasCar,
		&i.RegisteredAt,
		&i.CancelledAt,
	)
	return i, err
}

const updateConference = `-- name: UpdateConference :one
UPDATE conferences SET
    title = COALESCE($2, title),
    date = COALESCE($3, date),
    location = COALESCE($4, location),
    website = COALESCE($5, website),
    latitude = COALESCE($6, latitude),
    longitude = COALESCE($7, longitude),
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, date, location, website, latitude, longitude, created_at, updated_at
`

type UpdateConferenceParams struct {
	ID        uuid.UUID
	Title     string
	Date      time.Time
	Location  string
	Website   *string
	Latitude  *float64
	Longitude *float64
}

func (q *Queries) UpdateConference(ctx context.Context, arg UpdateConferenceParams) (Conference, error) {
	row := q.db.QueryRow(ctx, updateConference,
		arg.ID,
		arg.Title,
		arg.Date,
		arg.Location,
		arg.Website,
		arg.Latitude,
		arg.Longitude,
	)
	var i Conference
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Date,
		&i.Location,
		&i.Website,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRegistrationStatus = `-- name: UpdateRegistrationStatus :one
UPDATE conference_registrations SET status = $2
WHERE id = $1
RETURNING id, user_id, conference_id, status, role, notes, needs_ride, has_car, registered_at, cancelled_at
`

type UpdateRegistrationStatusParams struct {
	ID     uuid.UUID
	Status string
}

func (q *Queries) UpdateRegistrationStatus(ctx context.Context, arg UpdateRegistrationStatusParams) (ConferenceRegistration, error) {
	row := q.db.QueryRow(ctx, updateRegistrationStatus, arg.ID, arg.Status)
	var i ConferenceRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ConferenceID,
		&i.Status,
		&i.Role,
		&i.Notes,
		&i.NeedsRide,
		&i.HasCar,
		&i.RegisteredAt,
		&i.CancelledAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
    name = COALESCE($2, name),
    nickname = COALESCE($3, nickname),
    city = COALESCE($4, city),
    avatar_url = COALESCE($5, avatar_url),
    bio = COALESCE($6, bio),
    updated_at = NOW()
WHERE id = $1
RETURNING id, email, password, name, nickname, city, avatar_url, bio, created_at, updated_at
`

type UpdateUserParams struct {
	ID        uuid.UUID
	Name      string
	Nickname  *string
	City      *string
	AvatarUrl *string
	Bio       *string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Nickname,
		arg.City,
		arg.AvatarUrl,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Nickname,
		&i.City,
		&i.AvatarUrl,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users SET password = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, email, password, name, nickname, city, avatar_url, bio, created_at, updated_at
`

type UpdateUserPasswordParams struct {
	ID       uuid.UUID
	Password string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.ID, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Nickname,
		&i.City,
		&i.AvatarUrl,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
